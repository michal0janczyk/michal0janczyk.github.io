<!-- wp:paragraph -->
<p>The first thing to understand is that a string in Python or C ++ is a variable length array.This seemingly small difference is quite important from a systemic point of view:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>a normal array is statically determined in the program from the start</li><li>has a known length</li><li>we know how to read individual elements</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Since the length of the table can change while the program is running, the compiler needs additional information - a line end marker, which is a special code of zeros </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2><strong>Strings in Python</strong></h2>
<!-- /wp:heading -->

<!-- wp:syntaxhighlighter/code -->
<pre class="wp-block-syntaxhighlighter-code">>>> import sys
>>> sys.getsizeof("")
40</pre>
<!-- /wp:syntaxhighlighter/code -->

<!-- wp:paragraph -->
<p>In Python strings are objects, so that values is the size of the object itself. So this size will always be bigger than the string size itself.From <code>stringobject.h</code>:</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>typedef struct {
    PyObject_VAR_HEAD
    long ob_shash;
    int ob_sstate;
    char ob_sval&#91;1];

    /* Invariants:
     *     ob_sval contains space for 'ob_size+1' elements.
     *     ob_sval&#91;ob_size] == 0.
     *     ob_shash is the hash of the string or -1 if not computed yet.
     *     ob_sstate != 0 iff the string object is in stringobject.c's
     *       'interned' dictionary; in this case the two references
     *       from 'interned' to this object are *not counted* in ob_refcnt.
     */
} PyStringObject;</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>From here you can get some clues on how those bytes are used:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><code>len(str)+1</code> bytes to store the string itself</li><li>8 bytes for the hash</li></ul>
<!-- /wp:list -->

<!-- wp:getwid/toggle -->
<div class="wp-block-getwid-toggle has-icon-left"><!-- wp:getwid/toggle-item -->
<div class="wp-block-getwid-toggle__row"><div class="wp-block-getwid-toggle__header-wrapper"><span class="wp-block-getwid-toggle__header"><a href="#"><span class="wp-block-getwid-toggle__header-title"><strong>Exercise #1. Reverse Strings</strong></span><span class="wp-block-getwid-toggle__icon is-active"><i class="fas fa-plus"></i></span><span class="wp-block-getwid-toggle__icon is-passive"><i class="fas fa-minus"></i></span></a></span></div><div class="wp-block-getwid-toggle__content-wrapper"><div class="wp-block-getwid-toggle__content"><!-- wp:paragraph -->
<p>In this first exercise, the goal is to write a function that takes a string as input and then returns the reversed string.For example, if the input is the string <code>water</code>, then the output should be <code>retaw</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>def string_reverser(our_string):
    # New empty string for us to build on
    new_string = ""
    # Iterate over old string
    for i in range(len(our_string)):
    # Grab the charecter from the back of the string and add them to the new str
        new_string += our_string&#91;(len(our_string)-1)-i]
    # Return our solution
    return new_string</code></pre>
<!-- /wp:code --></div></div></div>
<!-- /wp:getwid/toggle-item -->

<!-- wp:getwid/toggle-item -->
<div class="wp-block-getwid-toggle__row"><div class="wp-block-getwid-toggle__header-wrapper"><span class="wp-block-getwid-toggle__header"><a href="#"><span class="wp-block-getwid-toggle__header-title"><strong>Exercise #2. &nbsp;Anagrams</strong></span><span class="wp-block-getwid-toggle__icon is-active"><i class="fas fa-plus"></i></span><span class="wp-block-getwid-toggle__icon is-passive"><i class="fas fa-minus"></i></span></a></span></div><div class="wp-block-getwid-toggle__content-wrapper"><div class="wp-block-getwid-toggle__content"><!-- wp:paragraph -->
<p>An anagram is a word or sentence created after rearranging the letters of another word (sentence). Both words are composed of the same letters but in a different order.For example:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>"rat" is an anagram of "art"</li><li>"alert" is an anagram of "alter"</li><li>"Slot machines" is an anagram of "Cash lost in me"</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>Method 1 (Use Sorting) [Time Complexity: O(n log n)]</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>Sort both strings</li><li>Compare the sorted strings</li></ol>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>def anagram_checker(str1, str2):
  if len(str1) != len(str2):
      # Clean strings
      clean_str_1 = str1.replace(" ", "").lower()
      clean_str_2 = str2.replace(" ", "").lower()
      if sorted(clean_str_1) == sorted(clean_str_2):
          return True
  return False</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><strong>Method 2 (Count characters)</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This method assumes that the set of possible characters in both strings is small. In the following implementation, it is assumed that the characters are stored using 8 bit and there can be 256 possible characters.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Method 3 (Count characters using one array) [Time Complexity: O(n)]</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The above implementation can be further to use only one count array instead of two. We can increment the value in count array for characters in str1 and decrement for characters in str2. Finally, if all count values are 0, then the two strings are anagram of each other. </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>bool areAnagram(char* str1, char* str2) 
{ 
// Create a count array and initialize all values as 0 
int count&#91;NO_OF_CHARS] = { 0 }; 
int i;
// For each character in input strings, increment count in 
// the corresponding count array 
for (i = 0; str1&#91;i] &amp;&amp; str2&#91;i]; i++) { 
    count&#91;str1&#91;i]]++; 
    count&#91;str2&#91;i]]--; 
} 

// If both strings are of different length. Removing this condition 
// will make the program fail for strings like "aaca" and "aca" 
if (str1&#91;i] || str2&#91;i]) 
    return false; 

// See if there is any non-zero value in count array 
for (i = 0; i &lt; NO_OF_CHARS; i++) 
    if (count&#91;i]) 
        return false; 
return true; 
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph --></div></div></div>
<!-- /wp:getwid/toggle-item -->

<!-- wp:getwid/toggle-item -->
<div class="wp-block-getwid-toggle__row"><div class="wp-block-getwid-toggle__header-wrapper"><span class="wp-block-getwid-toggle__header"><a href="#"><span class="wp-block-getwid-toggle__header-title"><strong>Exercise 3. &nbsp;Hamming Distance</strong></span><span class="wp-block-getwid-toggle__icon is-active"><i class="fas fa-plus"></i></span><span class="wp-block-getwid-toggle__icon is-passive"><i class="fas fa-minus"></i></span></a></span></div><div class="wp-block-getwid-toggle__content-wrapper"><div class="wp-block-getwid-toggle__content"><!-- wp:paragraph -->
<p>In information theory, the Hamming distance between two strings of equal length is the number of positions at which.A measure of the difference of two strings of the same length, expressing the number of places (positions) in which the two strings differ. In other words, it is the fewest number of changes (replacing an item with another) that can make one string into another.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>def hamming_distance(str1, str2):
  if len(str1) == len(str2):
      count = 0
      for char in range(len(str1)):
          if str1&#91;char] != str2&#91;char]:
              count+=1
      return count
  return None</code></pre>
<!-- /wp:code --></div></div></div>
<!-- /wp:getwid/toggle-item --></div>
<!-- /wp:getwid/toggle -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->
